# 约瑟夫问题 2746: 约瑟夫问题

题目要求计算未知初值的约瑟夫问题。

[题目来源](http://bailian.openjudge.cn/practice/2746/)

## 2746: 约瑟夫问题

总时间限制: 1000ms    内存限制: 65536kB

### 描述

约瑟夫问题：有ｎ只猴子，按顺时针方向围成一圈选大王（编号从1到ｎ），从第1号开始报数，一直数到ｍ，数到ｍ的猴子退出圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王，编程求输入ｎ，ｍ后，输出最后猴王的编号。

### 输入

每行是用空格分开的两个整数，第一个是 n, 第二个是 m ( 0 < m,n <=300)。最后一行是：

0 0

### 输出

对于每行输入数据（最后一行除外)，输出数据也是一行，即最后猴王的编号

### 样例输入
```
6 2
12 4
8 3
0 0
```
### 样例输出
```
5
1
7
```
对于没有围成一圈的情况大家可能都比较熟悉，对于围成一圈的情况，每次需要在猴子总数上减一作为除数取余来得到下一次剔除的下标，最后剩一个即为所求。
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
	int n, m, i;
	while(true) { 
		cin >> n >> m;
		if (n == 0 && m == 0) {
			break;
		}
		vector<int> vMonkey;
		for (i = 0; i < n; ++i) {
			vMonkey.push_back(i + 1);
		}
		int idx = 0;
		while (vMonkey.size() > 1) {
			n = vMonkey.size();
			idx = (idx + m) % n - 1;
			if (idx < 0) {
				idx = n - 1;
			}
			vMonkey.erase(vMonkey.begin() + idx);
		}
		cout << vMonkey[0] << endl;
	}
	return 0;
}
```
#### [2746.cpp](/Code/2700-2799/2746.cpp) 代码长度：471B 内存：128kB 时间：2ms 通过率：93% 最小内存：128kB  最短时间：0ms

对于类似问题，可以采用现有的数据结构进行改进，这里使用了vector线性表，也可以考虑list列表来完成删除操作。取余直接求出下标是一种较为快速的方法，也可以考虑模拟实际过程，更加容易理解。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
