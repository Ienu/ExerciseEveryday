# 八皇后问题 2754: 八皇后

题目要求输出八皇后问题的某一个解。

[题目来源](http://bailian.openjudge.cn/practice/2754/)

## 2754: 八皇后

总时间限制: 1000ms    内存限制: 65536kB

### 描述

会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。
如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。 

对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。
已经知道8皇后问题一共有92组解（即92个不同的皇后串）。
给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。

### 输入

第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 <= b <= 92)

### 输出

输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。

### 样例输入
```
2
1
92
```
### 样例输出
```
15863724
84136275
```
由于不知道要输出哪一个解，因此可以事先把所有解都计算按要求的顺序存储起来，根据输入直接输出。
可以采用深度优先搜索的方法，这样得出的解的顺序与题目要求的一致。
对于深度优先搜索，可以使用递归的方式进行求解。
从第一行第一个元素开始，逐行试探之后行的每一个元素是否满足不在同一列和同一斜线的条件，每当成立便向下一行进行递归。
到最后一行仍然成立，则可以把该解存储起来。
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cmath>
using namespace std;
vector<string> vs;
bool isOK(vector<int> vp, int x) {
	int i, s = vp.size();
	for (i = 0; i < s; ++i) {
		if (vp[i] == x || abs(i - s) == abs(vp[i] - x)) {
			return false;
		}
	}
	return true;
}
void queen(vector<int> vp) {
	int i;
	if (vp.size() == 8) {
		string str(8, '1');
		for (i = 0; i < 8; ++i) {
			str[i] += vp[i];
		}
		vs.push_back(str);
	}
	else {
		for (i = 0; i < 8; ++i) {
			if (isOK(vp, i)) {
				vector<int> v = vp;
				v.push_back(i);
				queen(v);
			}
		}
	}
}
int main() {
	int n, i, m;
	cin >> n;
	vector<int> v;
	queen(v);
	for (i = 0; i < n; ++i) {
		cin >> m;
		cout << vs[m - 1] << endl;
	}
	return 0;
}
```
#### [2754.cpp](/Code/2700-2799/2754.cpp) 代码长度：727B 内存：136kB 时间：4ms 通过率：94% 最小内存：136kB  最短时间：0ms

可以构造一个判别是否满足八皇后条件的函数，用于判断当下行的位置与之前摆放好的元素是否冲突。
递归函数的参数应为已摆放好的前多少行的解，对于满足条件的解可以采用全局变量的方式存储。
当然对于解的存放可以考虑更高效的数据结构，这里使用了vector进行处理。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
