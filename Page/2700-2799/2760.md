# 数字三角形 2760: 数字三角形

题目要求计算数字三角形中从顶到底的数字和最大值。

[题目来源](http://bailian.openjudge.cn/practice/2760/)

## 2760: 数字三角形

总时间限制: 1000ms    内存限制: 65536kB

### 描述

![](fig2760.png)

图1给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。

注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。

### 输入

输入的是一行是一个整数N (1 < N <= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。

### 输出

输出最大的和。

### 样例输入
```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```
### 样例输出
```
30
```
这是一个动态规划问题，如果遍历全部路径将非常耗时，可以从底部开始动态规划。对于每一个上层节点都有左右两个分支，我们更新该节点的值为左右两个分支节点的最大值加上该节点本身即可。如此从下到上直到剩余一个节点，即为最后要求的最大值。
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
	int n, i, j, temp;
	cin >> n;
	vector<vector<double> > vv;
	for (i = 1; i <= n; ++i) {
		vector<double> v;
		for (j = 0; j < i; ++j) {
			cin >> temp;
			v.push_back(temp);
		}
		vv.push_back(v);
	}
	for (i = vv.size() - 2; i >= 0; --i) {
		for (j = 0; j < vv[i].size(); ++j) {
			double max = vv[i + 1][j];
			if (max < vv[i + 1][j + 1]) {
				max = vv[i + 1][j + 1];
			}
			vv[i][j] += max;
		}
	}
	cout << vv[0][0] << endl;
	return 0;
}
```
#### [2760.cpp](/Code/2700-2799/2760.cpp) 代码长度：514B 内存：308kB 时间：15ms 通过率：95% 最小内存：308kB  最短时间：1ms

这里我采用了两层vector模板来存储，当然也可以分配矩阵空间控制下标进行计算。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
