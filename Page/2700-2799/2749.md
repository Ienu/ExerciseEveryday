# 分解因数 2749: 分解因数

题目要求将给定的数分解成整数的乘积，求能够分解得到的种数。

[题目来源](http://bailian.openjudge.cn/practice/2749/)

## 2749: 分解因数

总时间限制: 1000ms    内存限制: 65536kB

### 描述

给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * ... * an，并且1 < a1 <= a2 <= a3 <= ... <= an，问这样的分解的种数有多少。注意到a = a也是一种分解。

### 输入

第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 < a < 32768)。

### 输出

n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。

### 样例输入
```
2
2
20
```
### 样例输出
```
1
4
```
由于分解后的排列要求由小到大，因此我们可以从小到大遍历给定数的因子，在除去该因子以后，对商进行同样的操作，但前提是因子要比之前的大。从这个递推规则可以构建递归函数求解，针对每一种分解累加一种可能。
```cpp
#include <iostream>
using namespace std;
int factor(int number, int s) {
	int i, sum = 1;
	for (i = s; i * i <= number; ++i) {
		if (number % i == 0 && i <= number / i) {
			sum += factor(number / i, i);
		}
	}
	return sum;
}
int main() {
	int n, i, num;
	cin >> n;
	for (i = 0; i < n; ++i) {
		cin >> num;
		cout << factor(num, 2) << endl;
	}
	return 0;
}
```
#### [2749.cpp](/Code/2700-2799/2749.cpp) 代码长度：357B 内存：136kB 时间：3ms 通过率：93% 最小内存：136kB  最短时间：0ms

第一次涉及稍微复杂的递归问题，这要是思考如何产生递推规则，最基本的情况就是只有其本身作为因子，也是递归到最后的情况，因此将sum设为1，当for循环无可执行次数时，恰好也返回1作为一次累加，另外由于要求因子逐渐增大，因此判别时除了整除外需加上大小判别条件。最小的因子应为2，因此在主函数中以2为起始进行调用。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
