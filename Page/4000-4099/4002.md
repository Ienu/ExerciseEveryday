# 共同爱好 4002: 谁是你的潜在朋友

题目要求从给定的记录找到具有相同借阅记录的读者的数量，以此来判断潜在的朋友。

[题目来源](http://bailian.openjudge.cn/practice/4002/)

## 4002: 谁是你的潜在朋友

总时间限制: 1000ms    内存限制: 65536kB

### 描述

“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。

首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。

### 输入

第一行两个整数N,M，2 <= N ，M<= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1<=P<=M)

### 输出

包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）

### 样例输入
```
4  5
2
3
2
1
```
### 样例输出
```
1
BeiJu
1
BeiJu
```
我们已经知道有多少本图书，就可以在遍历借阅记录的时候，对借阅过的数目次数进行计数，由于每个人只借过一本，因此最后判断该数目的借阅数量是否大于1就可以知道是否还有其他人借阅过同一本书。
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main() {
	int n, m, i;
	cin >> n >> m;
	int* book = new int[n];
	int* data = new int[m];
	memset(data, 0, sizeof(int) * m);
	for (i = 0; i < n; ++i) {
		cin >> book[i];
		data[book[i] - 1]++;
	}
	for (i = 0; i < n; ++i) {
		if (data[book[i] - 1] > 1) {
			cout << data[book[i] - 1] - 1 << endl;
		}
		else {
			cout << "BeiJu" << endl;
		}
	}
	delete[] book;
	delete[] data;
	return 0;
}
```
#### [4002.cpp](/Code/4000-4099/4002.cpp) 代码长度：452B 内存：160kB 时间：3ms 通过率：97% 最小内存：160kB  最短时间：0ms

由于事先不知道人数和书的数量，可以采用动态内存分配的方式，但对于零初始化则需使用memset，之后遍历每一个人的借阅情况对于大于1的结果输出数字，最后释放内存。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
