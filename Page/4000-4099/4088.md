# 集合运算 4088: 集合运算

题目要求计算两个给定集合交集以外的元素构成的集合，并排序输出。

[题目来源](http://bailian.openjudge.cn/practice/4088/)

## 4088: 集合运算

总时间限制: 3000ms 单个测试点时间限制: 1000ms 内存限制: 65536kB

### 描述

设 A = {a1, a2, … , an}, B = {b1, b2, … , bm} 是非负整数集合，其中m = O(logn)。

设计算法计算集合 C = (A − B) ∪ (B − A)。

### 输入

输入文件包含2行。

第1行的第一个数为n，表示A集合的大小，接下来跟有A集合中的包含的n个非负整数。

第2行的第一个数为m，表示B集合的大小，接下来跟有B集合中的包含的m个非负整数。

两个集合中的数按照从小到大的顺序给出，n <= 106

### 输出

输出文件包含1行，表示计算出的C集合中所包含的整数。

请将这些整数按照从小到大的顺序排序。

### 样例输入
```
8 1 3 5 6 8 10 12 30
3 1 3 7
```
### 样例输出
```
5 6 7 8 10 12 30
```
这个题目对于数据量较大的情况是一个挑战，在分别读入数据后，按照队列的方式，读取每一个集合的第一个元素并比较大小，将较小的输出。
如果相等则同时舍弃，最后还需将剩余元素输出。最后剩余只可能存在于两个集合之一。
```cpp
#include <cstdio>
using namespace std;
int main() {
	int *A, *B, n, m, i, j;
	scanf("%d", &n);
	A = new int[n];
	for (i = 0; i < n; ++i) {
		scanf("%d", &A[i]);
	}
	scanf("%d", &m);
	B = new int[m];
	for (i = 0; i < m; ++i) {
		scanf("%d", &B[i]);
	}
	i = 0, j = 0;
	while (i < n && j < m) {
		if (A[i] < B[j]) {
			printf("%d ", A[i++]);
		}
		else if (B[j] < A[i]) {
			printf("%d ", B[j++]);
		}
		else {
			i++;
			j++;
		}
	}
	for (; i < n; ++i) {
		printf("%d ", A[i]);
	}
	for (; j < m; ++j) {
		printf("%d ", B[j]);
	}
	printf("\n");
	delete[] A;
	delete[] B;
	return 0;
}
```
#### [4088.cpp](/Code/4000-4099/4088.cpp) 代码长度：581B 内存：39768kB 时间：2204ms 通过率：78% 最小内存：39768kB  最短时间：1728ms

需要采用C语言的输入输出流来读取和输出，否则会超时。未知大小的数组可以采用动态内存分配的方式。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
