# 解方程 2697: 迭代法解方程

题目要求使用迭代法来解方程，实际是二分法。

[题目来源](http://bailian.openjudge.cn/practice/2697/)

## 2697: 迭代法解方程

总时间限制: 2000ms    内存限制: 65536kB

### 描述

对函数y = f(x) = x*x*x + x + a（其中a大于0）。要直接求y=0时x的取值并不容易，但因为y是单调递增的函数，我们可以利用这个性质求x的近似值。取x1＝-a，显然f(-a)小于0，取x2=0，显然f(a)大于0。我们规定近似误差不超过b（比如b=0.001）。这时我们取x=(x2+x1)/2，再判断(x2-x1)是否小于b，如果小于b，x就是我们要求的值，否则我们需要判断f(x)的取值，如果f(x)大于0，令x2=x，重新求解；如果f(x)小于0，令x1=x，也重新求解；如果f(x)恰好等于0，则以此x应作为最终x的取值。我们把这种求解的过程称为迭代法。

### 输入

第一行为数据数量n。其余个行每行包含两个浮点数a和b。

### 输出

输出为n行，每行输出对应的x和y的值。

### 样例输入
```
3
23 0.01
23 0.001
23 0.0001
```
### 样例输出
```
-2.726196 0.012314
-2.726547 0.004137
-2.726767 -0.000974
```
个人觉得原题的说明有错误，实际上应该是一个二分法求解问题，不知道是不是我自己理解错误，总之是在给定精度下，在不满足的条件下就迭代求解，不断缩小解的区间。
```cpp
#include <iostream>
#include <iomanip>
using namespace std;
double f(double x, double a) {
	return x * x * x + x + a;
}
int main() {
	int n, i;
	float a, b;
	double x1, x2, x, y;
	cin >> n;
	for (i = 0; i < n; ++i) {
		cin >> a >> b;
		x1 = -a;
		x2 = 0;
		while(true) {
			x = (x2 + x1) / 2;
			y = f(x, a);
			if (x2 - x1 < b) {
				cout << setprecision(6) << fixed << x << " " << y << endl;
				break;
			}
			else if (y > 0) {
				x2 = x;
			}
			else if (y < 0) {
				x1 = x;
			}
		}
	}
	return 0;
}
```
#### [2697.cpp](/Code/2600-2699/2697.cpp) 代码长度：506B 内存：128kB 时间：3ms 通过率：86% 最小内存：128kB  最短时间：0ms

这里我单独定义了一个函数来方便求解函数值，每次取区间左右端点的中值来判断函数值是否满足精度，如果不满足且大于0，则把中间点作为新的端点，如此最后可以得到满足精度的结果。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
