# 肿瘤检测 2677: 肿瘤检测

题目给出了肿瘤图像的像素特征，要求统计肿瘤面积和边长。

[题目来源](http://bailian.openjudge.cn/practice/2677/)

## 2677: 肿瘤检测

总时间限制: 1000ms    内存限制: 65536kB

### 描述

一张CT扫描的灰度图像可以用一个N*N（0 < N <= 100）的矩阵描述，矩阵上的每个点对应一个灰度值（整数），其取值范围是0-255。
我们假设给定的图像中有且只有一个肿瘤。在图上监测肿瘤的方法如下：如果某个点对应的灰度值小于等于50，则这个点在肿瘤上，否则不在肿瘤上。
我们把在肿瘤上的点的数目加起来，就得到了肿瘤在图上的面积。任何在肿瘤上的点，如果它是图像的边界或者它的上下左右四个相邻点中至少有一个是非肿瘤上的点，则该点称为肿瘤的边界点。
肿瘤的边界点的个数称为肿瘤的周长。现在给定一个图像，要求计算其中的肿瘤的面积和周长。

### 输入

输入第一行包含一个正整数N（0 < N <= 100），表示图像的大小；接下来N行，每行包含图像的一行。
图像的一行用N个整数表示（所有整数大于等于0，小于等于255），两个整数之间用一个空格隔开。

### 输出

输出只有一行，该行包含两个正整数，分别为给定图像中肿瘤的面积和周长，用一个空格分开。

### 样例输入
```
6
99 99 99 99 99 99
99 99 99 50 99 99
99 99 49 49 50 51
99 50 20 25 52 99
40 50 99 99 99 99
99 99 99 99 99 99
```
### 样例输出
```
9 8
```
为了减少二维数组的开销，可以采用一维数组进行操作，但行列操作起来没有二维数组方便。
肿瘤区域的判别比较简单，但边长的判别需要考虑多种因素，包括是否在边界上以及周围是否有非边界点。
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
	int N, i, area = 0, perimeter = 0;
	cin >> N;
	int* data = new int[N * N];
	vector<int> index;
	for(i = 0; i < N * N; ++i) {
		cin >> data[i];
		if(data[i] <= 50) {
			area++;
			if(i % N == 0
				|| (i + 1) % N == 0
				|| i < N
				|| i >= N * N - N) {
				perimeter++;
			}
			else if(data[i - 1] > 50
				|| data[i - N] > 50) {
				perimeter++;
			}
			else {
				index.push_back(i);
			}
		}
	}
	for(i = 0; i < index.size(); ++i) {
		if(data[index[i] + 1] > 50
			|| data[index[i] + N] > 50) {
			perimeter++;
		}
	}
	cout << area << " " << perimeter << endl;
	delete[] data; 
	return 0;
}
```
#### [2677.cpp](/Code/2600-2699/2677.cpp) 代码长度：668B 内存：368kB 时间：24ms 通过率：92% 最小内存：368kB  最短时间：6ms

考虑采用一维数组进行存储，随着输入随着处理，但要考虑该像素之后一个像素以及之下一个像素必须在读入全部数据后判别，因此可以存储这类无法判别的点后，待输入完成再进行判别。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
