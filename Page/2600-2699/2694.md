# 逆波兰表达式 2694: 逆波兰表达式

题目要求计算给出的仅包含四则运算的逆波兰表达式的值。

[题目来源](http://bailian.openjudge.cn/practice/2694/)

## 2694: 逆波兰表达式

总时间限制: 1000ms    内存限制: 65536kB

### 描述

逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的逆波兰表示法为* + 2 3 4。本题求解逆波兰表达式的值，其中运算符包括+ - * /四个。

可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在math.h中。

此题可使用函数递归调用的方法求解。

### 输入

输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。

### 输出

输出为一行，表达式的值。

可直接用printf("%f\n", v)输出表达式的值v。

### 样例输入
```
* + 11.0 12.0 + 24.0 35.0
```
### 样例输出
```
1357.000000
```
题目描述的是将运算符前置的表达式，实际上，逆波兰表达式是指把运算数放在前面，操作符放在后面的表达式，当然这里我们按照题目的描述来分析。

在二叉树中这相当于一个先序遍历的过程，从逻辑上分析，我们可以知道，每一个操作符后一定会有两个操作数，在迭代当中，也可以认为其中的操作数也可以是表达式。

这样我们就可以采用递归的方式进行处理，首先读入每一个符号，然后判断符号为操作符还是操作数，如果是操作符就要再读入两个操作数，每一个操作符应当返回一个值，最终只剩下一个值就应该是结果。
```cpp
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;
double invPoland() {
	double a, b;
	string str;
	cin >> str;
	if (str == "+" || str == "-" || str == "*" || str == "/") {
		a = invPoland();
		b = invPoland();
		switch (str[0]) {
		case '+':
			return a + b;
		case '-':
			return a - b;
		case '*':
			return a * b;
		case '/':
			return a / b;
		}
	}
	return stof(str);
}
int main() {
	cout << setprecision(6) << fixed << invPoland() << endl;
	return 0;
}
```
#### [2694.cpp](/Code/2600-2699/2694.cpp) 代码长度：486B 内存：128kB 时间：1ms 通过率：91% 最小内存：128kB  最短时间：0ms

可以在递归函数当中进行读取操作，利用string类型方便转换操作数，针对操作符进行switch操作获取表达式的值，最后按照精度输出即可。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
