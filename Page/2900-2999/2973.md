# 斜二进制数 2973: Skew数

题目要求将给定的斜二进制数转换为十进制数。

学习Jeff Duntemann的《汇编语言：基于Linux环境》越来越觉得与中文教材不同，当然美国人写的书与中国人风格截然不同。汇编语言是最早的编程语言了，介乎机器语言与低级语言之间，我不知道这么说是否准确。因为仅读过王爽的《汇编语言》，所以每次也只能把它拿出来做对比。当然Jeff这本书并不是教材，但他把大量的个人经历和计算机发展历史融入其中，两本书都是采用循序渐进的书写方法。Jeff这一本已经是第三版了，他的讨论中也详细介绍了之前MS-DOS实模式的编程，但是那是在他以前的版本中。王爽的书非常基础，很适合初学者，但书中的气息过于死板，只能说是一本教材。但实模式已经淘汰，国内也再没有类似的循序渐进的教材了，估计作者也是限于当前的体制要求，出书什么的没什么价值。非常希望王爽老师能够推出新版的汇编语言与时俱进，另外也希望能够出一本类似叙述方式的《操作系统》。没有一本好的教材，中国的科技落后30年的面貌是无法改变的。即使我们能够跟随国外的脚步，我们的创新能力也是差之千里的。

[题目来源](http://bailian.openjudge.cn/practice/2973/)

## 2973: Skew数

总时间限制: 1000ms    内存限制: 65536kB

### 描述

在 skew binary表示中, 第 k 位的值xk表示xk*(2k+1-1)。 每个位上的可能数字是0 或 1，最后面一个非零位可以是2, 例如, 10120(skew) = 1*(25-1) + 0*(24-1) + 1*(23-1) + 2*(22-1) + 0*(21-1) = 31 + 0 + 7 + 6 + 0 = 44. 前十个skew数是 0、1、2、10、11、12、20、100、101、以及102。

### 输入

输入包含一行或多行，每行包含一个整数n。 如果 n = 0 表示输入结束，否则n是一个skew 数

### 输出

对于每一个输入，输出它的十进制表示。转换成十进制后， n 不超过 231-1 = 2147483647

### 样例输入
```
10120
200000000000000000000000000000
10
1000000000000000000000000000000
11
100
11111000001110000101101102000
0
```
### 样例输出
```
44
2147483646
3
2147483647
4
7
1041110737
```
这是我编写的简单版本，忽略了2作为一个非零位结束符的特征，如果考虑这一情况能提高运算速度。我就按照一般情形进行处理，这是一个典型的进制转换问题，不停地更新基数累加加权求和即可。
```cpp
#include <iostream>
#include <string>
using namespace std;
int main() {
	string str;
	int i;
	while (cin >> str && str != "0") {
		long sum = 0, bin = 1;
		for (i = str.length() - 1; i >= 0; --i) {
			bin <<= 1;
			sum += (str[i] - '0') * (bin - 1);
		}
		cout << sum << endl;
	}
	return 0;
}
```
#### [2973.cpp](/Code/2900-2999/2973.cpp) 代码长度：293B 内存：136kB 时间：3ms 通过率：98% 最小内存：136kB  最短时间：0ms

由于输入可能非常长，另外为了方便每一位的处理，应当用字符串来存储输入，之后从右向左依次处理每一位，先转换为数字，之后乘以每一位的权重，累加即可。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
