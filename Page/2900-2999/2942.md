///# 判断标志 2942: 吃糖果

///题目要求计算最小的正整数a使得a和该数减a均为另外一个数的因子。

[题目来源](http://bailian.openjudge.cn/practice/2942/)

## 2942: 吃糖果

总时间限制: 1000ms    内存限制: 65536kB

### 描述

名名的妈妈从外地出差回来，带了一盒好吃又精美的巧克力给名名（盒内共有 N 块巧克力，20 > N >0）。妈妈告诉名名每天可以吃一块或者两块巧克力。假设名名每天都吃巧克力，问名名共有多少种不同的吃完巧克力的方案。例如：如果N=1，则名名第1天就吃掉它，共有1种方案；如果N=2，则名名可以第1天吃1块，第2天吃1块，也可以第1天吃2块，共有2种方案；如果N=3，则名名第1天可以吃1块，剩2块，也可以第1天吃2块剩1块，所以名名共有2+1=3种方案；如果N=4，则名名可以第1天吃1块，剩3块，也可以第1天吃2块，剩2块，共有3+2=5种方案。现在给定N，请你写程序求出名名吃巧克力的方案数目。

### 输入

输入只有1行，即整数N。

### 输出

输出只有1行，即名名吃巧克力的方案数。

### 样例输入
```
4
```
### 样例输出
```
5
```
///判断因子是整除问题，由于要求最小的那个数，循环从1到M/2即可，但需要一个额外的判断标志来标识是否找到了最小的因子。
```cpp
#include <iostream>
using namespace std;
int main() {
	int n, i, a[3] = { 1, 1, 2 };
	cin >> n;
	if (n < 3) {
		cout << a[n] << endl;
	}
	else {
		for (i = 0; i < n - 2; ++i) {
			a[0] = a[1];
			a[1] = a[2];
			a[2] = a[0] + a[1];
		}
		cout << a[2] << endl;
	}
	return 0;
}
```
///#### [2942.cpp](/Code/2900-2999/2942.cpp) 代码长度：276B 内存：200kB 时间：15ms 通过率：93% 最小内存：200kB  最短时间：0ms

///题目的取值范围较小，我们可以采用int类型存储，虽然找到最小数后可以break出来，但如果最后一个数是最小数，我们就无法判断是否已经找到，因为如果没有找到需要输出-1，所以需要一个额外的标志。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
