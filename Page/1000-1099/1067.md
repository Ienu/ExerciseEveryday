# 取石子游戏 1067: 取石子游戏

这是一个经典的游戏，但并没有想象的那么简单。

[题目来源](http://bailian.openjudge.cn/practice/1067/)

## 1067: 取石子游戏

总时间限制: 1000ms    内存限制: 65536kB

### 描述

有两堆石子，数量任意，可以不同。
游戏开始由两个人轮流取石子。
游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。
最后把石子全部取完者为胜者。
现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。

### 输入

输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。

### 输出

输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。

### 样例输入
```
2 1
8 4
4 7
```
### 样例输出
```
0
1
0
```
这是一个威佐夫博奕（Wythoff Game）问题，这个证明太复杂了，就不在这里细说了。
可以记住的是，对于满足的解的条件，是符合黄金分割的。
如果这两个数的比例满足黄金分割，则后取者为胜者。
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main() {
	long long a, b, c;
	double d = 1.5 - sqrt(5.0) / 2;
	while (cin >> a >> b) {
		if (a < b) {
			c = a;
			a = b;
			b = c;
		}
		cout << (a != (long long)((a - b) / d)) << endl;
	}
	return 0;
}
```
#### [1067.cpp](/Code/1000-1099/1067.cpp) 代码长度：265B 内存：200kB 时间：1ms 通过率：70% 最小内存：200kB  最短时间：0ms

整数是无法满足真正意义的黄金分割的，这里是说在取整的条件下考虑该问题。
开平方可以使用sqrt函数，由于给出的数可能较大，因此要使用long long类型存储和处理。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
