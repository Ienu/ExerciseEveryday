# 无需遍历 2886: 能被3除尽的数之和

能被3除尽的数实际上就是3的倍数，题目要求对小于等于给定数的所有这样的数求和，是一个求和问题。

[题目来源](http://bailian.openjudge.cn/practice/2886/)

## 2886: 能被3除尽的数之和

总时间限制: 1000ms    内存限制: 65536kB

### 描述

输入一个非负整数n（n≥0），求从0到n之间（注意包括n）所有能被3除尽的数之和。

### 输入

非负整数：n。

### 输出

[0，n]之间能被3除尽的数之和：sum。

### 样例输入
```
1
9
```
### 样例输出
```
0
18
```
从表面上看我们只需要从0遍历到n，然后判断余数求和即可，但实际上我们知道这是一个等差数列，我们可以不采用遍历的方式通过等差数列公式直接求和。这样我们仅需求出不大于n的最大的能被3除尽的数作为末项，0作为首项，求出项数再代入公式即可。
```cpp
#include <iostream>
using namespace std;
int main() {
	int n;
	while (cin >> n) {
		cout << (n - n % 3) * (n / 3 + 1) / 2 << endl;
	}
	return 0;
}
```
#### [2886.cpp](https://github.com/Ienu/ExerciseEveryday/blob/master/Code/2800-2899/2886.cpp) 代码长度：147B 内存：128kB 时间：2ms 通过率：95% 最小内存：128kB  最短时间：0ms

不大于n的最大的3的倍数为n - n % 3，由于int型除法会舍去小数部分，因此也可以采用n / 3 * 3的方式舍去余数。但实际尝试发现，计算机更擅长循环遍历，如果采用循环的方式，消耗时间会更短。

有任何的改进意见欢迎大家在微信平台公众号主页面留言或者发表issue。
